// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User roles (legacy - being replaced by capabilities)
enum UserRole {
  USER
  ADMIN
  PROMPT_ADMIN  // Can edit all system prompts including sensitive ones
}

// User capabilities - granular permissions
enum Capability {
  ASK_QUESTIONS      // Quick questions, chat, view own history
  CREATE_PROJECTS    // Create/manage bulk projects, upload documents
  REVIEW_ANSWERS     // Verify, correct, flag/resolve answers
  MANAGE_KNOWLEDGE   // Create/edit skills, documents, URLs
  MANAGE_PROMPTS     // Edit system prompts (prompt builder)
  VIEW_ORG_DATA      // See org-wide question log, accuracy metrics
  MANAGE_USERS       // Assign capabilities, manage group mappings
  ADMIN              // Full access, system settings, delete anything
}

// NextAuth.js models
model User {
  id               String              @id @default(cuid())
  name             String?
  email            String?             @unique
  emailVerified    DateTime?
  image            String?
  role             UserRole            @default(USER) // Legacy - kept for backwards compatibility
  // Capabilities system
  capabilities        Capability[]     @default([ASK_QUESTIONS]) // Computed from SSO groups + manual
  manualCapabilities  Capability[]     @default([])              // Admin-granted overrides (persist across logins)
  ssoGroups           String[]         @default([])              // Last known SSO groups from login
  // Relations
  accounts         Account[]
  sessions         Session[]
  preferences      UserPreference?
  questionHistory  QuestionHistory[]
  chatSessions     ChatSession[]
  apiUsage         ApiUsage[]
  answerFeedback   AnswerFeedback[]
  ownedProjects    BulkProject[]       @relation("ProjectOwner")
  ownedSkills      Skill[]             @relation("SkillOwner")
  ownedCustomers   CustomerProfile[]   @relation("CustomerOwner")
  ownedDocuments   KnowledgeDocument[] @relation("DocumentOwner")
  ownedUrls        ReferenceUrl[]      @relation("UrlOwner")
  collateralOutputs CollateralOutput[]
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
}

// User Preferences - per-user settings including LLM speed preferences
model UserPreference {
  id                String   @id @default(cuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // LLM Speed settings - JSON object with feature-specific overrides
  // e.g., { "chat": "fast", "questions": "quality" }
  // null = use system defaults
  llmSpeedOverrides Json?

  // Future preference fields can be added here
  // theme            String?  @default("system")
  // defaultSkillIds  Json?    // Favorite skills to auto-select

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// SSO Group to Capabilities mapping
// Maps identity provider groups to application capabilities
model AuthGroupMapping {
  id           String       @id @default(cuid())
  provider     String       // "okta", "google", "azure", etc.
  groupId      String       // Group identifier from SSO token (e.g., group ID or name)
  groupName    String?      // Human-readable name for display
  capabilities Capability[] // Capabilities granted by this group
  isActive     Boolean      @default(true)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  @@unique([provider, groupId])
  @@index([provider])
  @@index([isActive])
}

model BulkProject {
  id             String   @id @default(uuid())
  name           String
  sheetName      String
  columns        String[] // Array of column names from spreadsheet
  createdAt      DateTime @default(now())
  lastModifiedAt DateTime @updatedAt
  ownerName      String?
  ownerId        String?  // Foreign key to User
  owner          User?    @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  assignedUsers  Json?    // Array of user IDs who can access this project
  customerName   String?  // Legacy: kept for backwards compatibility

  // Primary customer relationship (1-to-1)
  customerId     String?  // Foreign key to CustomerProfile
  customer       CustomerProfile? @relation("ProjectCustomer", fields: [customerId], references: [id], onDelete: SetNull)

  status         ProjectStatus @default(DRAFT)
  notes          String?

  // Review workflow fields
  reviewRequestedAt DateTime?
  reviewRequestedBy String?
  reviewedAt        DateTime?
  reviewedBy        String?

  rows              BulkRow[] // One-to-many relationship with BulkRow
  customerProfiles  ProjectCustomerProfile[] // Many-to-many with CustomerProfile (legacy)

  @@index([status])
  @@index([lastModifiedAt])
  @@index([ownerId])
  @@index([customerId])
}

model BulkRow {
  id                   String   @id @default(uuid())
  projectId            String
  rowNumber            Int
  question             String   @db.Text
  response             String   @db.Text @default("")
  status               RowStatus @default(PENDING)
  error                String?  @db.Text
  createdAt            DateTime @default(now())
  // Who asked/created this question (for org-wide tracking)
  askedById            String?  // User ID
  askedByName          String?  // Cached display name
  askedByEmail         String?  // Cached email
  conversationHistory  Json?    // Stored as JSON: { role: string; content: string }[]
  confidence           String?
  sources              String?  @db.Text
  reasoning            String?  @db.Text // What skills matched and what was found directly
  inference            String?  @db.Text // What was inferred/deduced, or "None" if everything was found directly
  remarks              String?  @db.Text
  usedSkills           Json?    // Stored as JSON: Skill[]
  showRecommendation   Boolean  @default(false)
  clarifyConversation  Json?    // Stored as JSON: { role: 'user' | 'assistant'; content: string }[]

  // Review flagging for individual questions
  flaggedForReview     Boolean  @default(false)
  flaggedAt            DateTime?
  flaggedBy            String?
  flagNote             String?  @db.Text

  // Flag resolution (preserves audit trail when closing flags)
  flagResolved         Boolean  @default(false)
  flagResolvedAt       DateTime?
  flagResolvedBy       String?
  flagResolutionNote   String?  @db.Text

  // Queue for batch review (persisted across sessions for collaboration)
  queuedForReview      Boolean  @default(false)
  queuedAt             DateTime?
  queuedBy             String?
  queuedNote           String?  @db.Text
  queuedReviewerId     String?  // Intended reviewer when queue is sent
  queuedReviewerName   String?

  // Review workflow fields (separate from flagging)
  reviewStatus         RowReviewStatus @default(NONE)
  reviewRequestedAt    DateTime?
  reviewRequestedBy    String?
  reviewNote           String?  @db.Text  // Note from requester to reviewer
  assignedReviewerId   String?  // User ID of assigned reviewer (null = anyone can review)
  assignedReviewerName String?  // Cached name for display
  reviewedAt           DateTime?
  reviewedBy           String?
  userEditedAnswer     String?  @db.Text  // If user manually corrected the answer

  project              BulkProject @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, rowNumber])
  @@index([projectId])
  @@index([status])
  @@index([flaggedForReview])
  @@index([queuedForReview])
  @@index([askedById])
  @@index([createdAt])
  // Composite indexes for common queries
  @@index([projectId, status])
  @@index([reviewStatus, createdAt])
  @@index([flagResolved, flaggedForReview])
}

enum ProjectStatus {
  DRAFT
  IN_PROGRESS
  NEEDS_REVIEW
  FINALIZED
}

enum RowStatus {
  PENDING
  COMPLETED
  ERROR
}

enum RowReviewStatus {
  NONE              // No review requested
  REQUESTED         // Review requested, awaiting reviewer
  APPROVED          // Reviewer approved the answer
  CORRECTED         // Reviewer corrected the answer
}

model KnowledgeDocument {
  id              String   @id @default(uuid())
  title           String
  filename        String
  fileType        String   // pdf, doc, docx, txt
  content         String   @db.Text // Extracted text content
  fileData        Bytes?   // Original file data for native document support (PDFs sent directly to Claude)
  fileSize        Int      // bytes
  categories      String[] // Uses same categories as Skills
  uploadedAt      DateTime @default(now())
  description     String?  @db.Text
  isTemplate      Boolean  @default(false) // Whether this doc is a template
  templateContent String?  @db.Text // LLM-generated markdown template version
  ownerId         String?  // Foreign key to User
  owner           User?    @relation("DocumentOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  createdBy       String?  // User email for display
  // Unified Knowledge Pipeline fields
  skillId         String?  // Link to skill if converted to skill
  isReferenceOnly Boolean  @default(false) // True if saved as reference without skill conversion

  @@index([uploadedAt])
  @@index([isTemplate])
  @@index([ownerId])
  @@index([skillId])
}

// Customer Profiles (The Rolodex)
model CustomerProfile {
  id              String   @id @default(uuid())
  name            String   // Company name
  industry        String?  // e.g., "Healthcare", "FinTech"
  website         String?  // Primary company URL

  // Static fields from Salesforce (read-only in app)
  salesforceId       String?  @unique // Salesforce Account ID - used to link GTM data
  region             String?  // e.g., "NA", "EMEA", "APAC" - from Salesforce
  tier               String?  // e.g., "Enterprise", "Mid-Market", "SMB" - from Salesforce
  employeeCount      Int?     // NumberOfEmployees from Salesforce
  annualRevenue      Float?   // AnnualRevenue from Salesforce (in USD)
  accountType        String?  // Customer, Prospect, Partner, etc. from Salesforce
  billingLocation    String?  // Combined BillingCity, State, Country
  lastSalesforceSync DateTime? // When static fields were last synced from Salesforce

  // New unified content field (markdown-structured prose)
  content         String?  @db.Text // Main profile content (replaces overview/products/challenges/keyFacts)
  considerations  String[] // Special notes/caveats about this customer (like skill edgeCases)
  sourceDocuments Json?    // Array of {id, filename, uploadedAt} - docs that built this profile

  // Legacy fields (deprecated - migrate to content field)
  overview        String   @db.Text // AI-generated company overview
  products        String?  @db.Text // Products/services description
  challenges      String?  @db.Text // Known challenges/pain points
  keyFacts        Json?    // Array of {label, value} pairs

  sourceUrls      Json?    // Array of {url, addedAt, lastFetchedAt}
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastRefreshedAt DateTime?
  createdBy       String?
  ownerId         String?  // Foreign key to User
  owner           User?    @relation("CustomerOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  owners          Json?    // Array of {name, email}
  history         Json?    // Audit trail entries

  // Git sync tracking (Phase 2 of git-first architecture)
  lastSyncedAt    DateTime?  // Last successful sync to/from git
  syncStatus      String?    // "synced", "pending", "failed", null = unknown
  gitCommitSha    String?    // Latest git commit SHA for this customer profile
  syncLogs        CustomerSyncLog[]

  // Relations
  primaryProjects   BulkProject[] @relation("ProjectCustomer") // Projects where this is the primary customer
  projects          ProjectCustomerProfile[] // Legacy many-to-many relation
  documents         CustomerDocument[]
  collateralOutputs CollateralOutput[]

  @@index([isActive, updatedAt])
  @@index([industry])
  @@index([ownerId])
  @@index([salesforceId])
  @@index([syncStatus])
  @@index([lastSyncedAt])
}

// Customer-specific documents (only used when this customer is selected)
model CustomerDocument {
  id              String   @id @default(uuid())
  customerId      String
  customer        CustomerProfile @relation(fields: [customerId], references: [id], onDelete: Cascade)
  title           String
  filename        String
  fileType        String   // pdf, doc, docx, txt, xlsx
  content         String   @db.Text // Extracted text content
  fileSize        Int      // bytes
  description     String?  @db.Text
  uploadedAt      DateTime @default(now())
  uploadedBy      String?  // User email for display
  // Document types for organization
  docType         String?  // proposal, meeting_notes, requirements, contract, other

  @@index([customerId])
  @@index([uploadedAt])
  @@index([docType])
}

// Customer Sync Log - Track git sync operations (Phase 2 of git-first architecture)
// Pattern copied from SkillSyncLog for consistency
model CustomerSyncLog {
  id            String   @id @default(cuid())
  customerId    String
  operation     String   // "create", "update", "delete", "refresh"
  direction     String   // "db-to-git", "git-to-db"
  status        String   // "pending", "success", "failed"
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  error         String?  @db.Text
  gitCommitSha  String?  // Git commit SHA for this sync
  syncedBy      String?  // User ID or "system" for automated syncs

  customer      CustomerProfile @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([status])
  @@index([startedAt])
  @@index([direction])
}

// Join table for Projects <-> CustomerProfiles (many-to-many)
model ProjectCustomerProfile {
  id        String   @id @default(uuid())
  projectId String
  profileId String
  addedAt   DateTime @default(now())

  project   BulkProject     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  profile   CustomerProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([projectId, profileId])
  @@index([projectId])
  @@index([profileId])
}

// Skills (Knowledge Gremlin)
model Skill {
  id              String   @id @default(uuid())
  title           String
  content         String   @db.Text
  categories      String[] // Broad capability areas
  quickFacts      Json?    // Array of {question, answer} - DEPRECATED (use content field)
  edgeCases       String[] // DEPRECATED (use content field)
  sourceUrls      Json?    // Array of {url, addedAt, lastFetchedAt}
  sourceDocuments Json?    // Array of {id, filename, uploadedAt} - docs that fed into this skill
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastRefreshedAt DateTime?
  createdBy       String?
  ownerId         String?  // Foreign key to User
  owner           User?    @relation("SkillOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  owners          Json?    // Array of {name, email} - legacy/additional owners
  history         Json?    // Audit trail entries

  // Review system fields (optional, defaults to category settings)
  requiresReview      Boolean?   // NULL = inherit from category, TRUE = requires review, FALSE = direct save
  minApprovers        Int?       // NULL = use category default (usually 1)
  approvers           String[]   @default([]) // Email addresses or user IDs of allowed approvers
  status              SkillStatus @default(PUBLISHED) // DRAFT, IN_REVIEW, PUBLISHED, ARCHIVED
  draftContent        String?    @db.Text // Content being drafted (for review workflow)
  pendingReviewers    Json?      // Array of {userId, email, status: "pending"|"approved"|"rejected", reviewedAt}
  reviewRequestedAt   DateTime?
  reviewRequestedBy   String?    // User ID or email who requested review
  reviewComments      Json?      // Array of {author, comment, timestamp, lineNumber?}

  // Git sync tracking
  lastSyncedAt        DateTime?  // Last successful sync to/from git
  syncStatus          String?    // "synced", "pending", "failed", null = unknown
  gitCommitSha        String?    // Latest git commit SHA for this skill
  syncLogs            SkillSyncLog[]

  @@index([isActive, updatedAt])
  @@index([ownerId])
  @@index([status])
  @@index([reviewRequestedAt])
  @@index([syncStatus])
  @@index([lastSyncedAt])
}

// Skill status for review workflow
enum SkillStatus {
  DRAFT          // Saved but not published
  IN_REVIEW      // Submitted for review
  PUBLISHED      // Live and active (default)
  ARCHIVED       // Archived/inactive
}

// Skill Categories
model SkillCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  color       String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Review settings for skills in this category
  requiresReview Boolean? // NULL = no, TRUE = skills in this category require review
  minApprovers   Int?     @default(1) // Minimum number of approvals needed
  approvers      String[] @default([]) // Email addresses or user IDs of allowed approvers

  @@index([sortOrder])
}

// Skill Sync Log - Track git sync operations for debugging and UI visibility
model SkillSyncLog {
  id            String   @id @default(cuid())
  skillId       String
  operation     String   // "create", "update", "delete", "refresh"
  direction     String   // "db-to-git", "git-to-db"
  status        String   // "pending", "success", "failed"
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  error         String?  @db.Text
  gitCommitSha  String?  // Git commit SHA for this sync
  syncedBy      String?  // User ID or "system" for automated syncs

  skill         Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@index([skillId])
  @@index([status])
  @@index([startedAt])
  @@index([direction])
}

// System Prompts (DEPRECATED - use PromptBlock instead)
model SystemPrompt {
  id        String   @id @default(uuid())
  key       String   @unique // e.g., "skill_builder", "chat", "customer_profile", "rfp_analysis"
  name      String   // Human-readable name
  sections  Json     // Array of {id, label, text, enabled, defaultText}
  updatedAt DateTime @updatedAt
  updatedBy String?

  @@index([key])
}

// Prompt Blocks - Reusable building blocks for composing prompts
model PromptBlock {
  id          String   @id @default(uuid())
  blockId     String   @unique // e.g., "role_mission", "output_format"
  name        String   // Human-readable name
  description String?  // What this block is for
  tier        Int      @default(3) // 1=Locked, 2=Caution, 3=Open
  variants    Json     // { "default": "...", "questions": "...", "skills": "..." }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedBy   String?

  // Git sync tracking (Phase 3 of git-first architecture)
  lastSyncedAt    DateTime?  // Last successful sync to/from git
  syncStatus      String?    // "synced", "pending", "failed", null = unknown
  gitCommitSha    String?    // Latest git commit SHA for this block
  syncLogs        PromptSyncLog[] @relation("BlockSyncLogs")

  @@index([blockId])
  @@index([syncStatus])
  @@index([lastSyncedAt])
}

// Prompt Modifiers - Runtime additions (mode, domain)
model PromptModifier {
  id         String   @id @default(uuid())
  modifierId String   @unique // e.g., "mode_single", "domain_technical"
  name       String   // Human-readable name
  type       String   // "mode" or "domain"
  tier       Int      @default(3) // 1=Locked, 2=Caution, 3=Open
  content    String   @db.Text // The prompt content
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  updatedBy  String?

  // Git sync tracking (Phase 3 of git-first architecture)
  lastSyncedAt    DateTime?  // Last successful sync to/from git
  syncStatus      String?    // "synced", "pending", "failed", null = unknown
  gitCommitSha    String?    // Latest git commit SHA for this modifier
  syncLogs        PromptSyncLog[] @relation("ModifierSyncLogs")

  @@index([modifierId])
  @@index([type])
  @@index([syncStatus])
  @@index([lastSyncedAt])
}

// Prompt Sync Log - Track git sync operations (Phase 3 of git-first architecture)
// Supports both blocks and modifiers in one table with entityType
model PromptSyncLog {
  id            String   @id @default(cuid())
  entityType    String   // "block" or "modifier"
  entityId      String   // blockId or modifierId (the unique key, not the UUID)
  operation     String   // "create", "update", "delete"
  direction     String   // "db-to-git", "git-to-db"
  status        String   // "pending", "success", "failed"
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  error         String?  @db.Text
  gitCommitSha  String?  // Git commit SHA for this sync
  syncedBy      String?  // User ID or "system" for automated syncs

  // Relations (optional - one will be set based on entityType)
  blockUuid     String?
  modifierUuid  String?
  block         PromptBlock?    @relation("BlockSyncLogs", fields: [blockUuid], references: [id], onDelete: Cascade)
  modifier      PromptModifier? @relation("ModifierSyncLogs", fields: [modifierUuid], references: [id], onDelete: Cascade)

  @@index([entityType, entityId])
  @@index([status])
  @@index([startedAt])
  @@index([direction])
}

// Reference URLs (global URL store for knowledge building)
model ReferenceUrl {
  id          String   @id @default(uuid())
  url         String   @unique
  title       String?
  description String?
  categories  String[] // Uses same categories as Skills
  addedAt     DateTime @default(now())
  lastUsedAt  DateTime?
  usageCount  Int      @default(0)
  ownerId     String?  // Foreign key to User
  owner       User?    @relation("UrlOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  createdBy   String?  // User email for display
  // Unified Knowledge Pipeline fields
  skillId         String?  // Link to skill if converted to skill
  isReferenceOnly Boolean  @default(false) // True if saved as reference without skill conversion

  @@index([addedAt])
  @@index([ownerId])
  @@index([skillId])
}

// Chat Prompts (prompt library for The Oracle)
model ChatPrompt {
  id          String   @id @default(uuid())
  title       String
  content     String   @db.Text
  category    String   // e.g., "custom", "builtin", or custom category id
  description String?
  isBuiltin   Boolean  @default(false)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?

  @@index([category])
  @@index([isBuiltin])
}

// Instruction Presets (persona/behavior instructions for chat)
model InstructionPreset {
  id               String                  @id @default(uuid())
  name             String
  content          String                  @db.Text // The instruction text
  description      String?                 // Brief description of what this preset is for
  isShared         Boolean                 @default(false) // If true, visible to all org users
  isDefault        Boolean                 @default(false) // If true, auto-selected for new chats
  shareStatus      InstructionShareStatus  @default(PRIVATE) // Approval workflow status
  shareRequestedAt DateTime?               // When share was requested
  approvedAt       DateTime?               // When approved
  approvedBy       String?                 // Admin who approved
  rejectedAt       DateTime?               // When rejected (if applicable)
  rejectedBy       String?                 // Admin who rejected
  rejectionReason  String?                 // Why it was rejected
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  createdBy        String?                 // User ID who created it
  createdByEmail   String?                 // For display

  @@index([isShared])
  @@index([shareStatus])
  @@index([createdBy])
}

enum InstructionShareStatus {
  PRIVATE           // Personal only, not shared
  PENDING_APPROVAL  // User requested to share, awaiting admin approval
  APPROVED          // Admin approved, now shared with org
  REJECTED          // Admin rejected the share request
}

// Context Snippets - Reusable boilerplate text for instructions
// e.g., company description, value props, certifications
model ContextSnippet {
  id          String   @id @default(uuid())
  name        String   // Human-readable name, e.g., "Company Description"
  key         String   @unique // Variable key, e.g., "company_description"
  content     String   @db.Text // The actual snippet text
  category    String?  // Optional grouping: "Company", "Product", "Compliance"
  description String?  // Brief description of what this snippet is for
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String?  // User email who created it

  @@index([category])
  @@index([isActive])
  @@index([key])
}

// Chat Prompt Categories
model ChatPromptCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  color       String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())

  @@index([sortOrder])
}

// Contract Reviews (The Clause Checker)
model ContractReview {
  id              String   @id @default(uuid())
  name            String   // Contract/document name
  filename        String   // Original filename
  fileType        String   // pdf, docx
  customerName    String?  // Who the contract is with
  contractType    String?  // e.g., "MSA", "DPA", "NDA", "SaaS Agreement"
  extractedText   String   @db.Text // Full extracted text
  status          ContractReviewStatus @default(PENDING)
  overallRating   String?  // "compliant", "mostly_compliant", "needs_review", "high_risk"
  summary         String?  @db.Text // AI-generated executive summary
  findings        Json?    // Array of ContractFinding objects
  skillsUsed      Json?    // Array of skill IDs used for analysis
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  analyzedAt      DateTime?
  reviewedAt      DateTime?
  reviewedBy      String?
  notes           String?  @db.Text

  @@index([status])
  @@index([createdAt])
  @@index([customerName])
}

enum ContractReviewStatus {
  PENDING      // Uploaded, not yet analyzed
  ANALYZING    // Analysis in progress
  ANALYZED     // Analysis complete, awaiting review
  REVIEWED     // Human reviewed
  ARCHIVED     // No longer active
}

// Question History - tracks quick questions from the home page
model QuestionHistory {
  id              String   @id @default(uuid())
  userId          String?  // Optional - null for anonymous users
  userEmail       String?  // For display purposes
  question        String   @db.Text
  response        String   @db.Text
  confidence      String?
  sources         String?  @db.Text
  reasoning       String?  @db.Text
  inference       String?  @db.Text
  remarks         String?  @db.Text
  skillsUsed      Json?    // Array of {id, title}
  createdAt       DateTime @default(now())

  // Review flagging for individual questions
  flaggedForReview     Boolean  @default(false)
  flaggedAt            DateTime?
  flaggedBy            String?
  flagNote             String?  @db.Text

  // Flag resolution (preserves audit trail when closing flags)
  flagResolved         Boolean  @default(false)
  flagResolvedAt       DateTime?
  flagResolvedBy       String?
  flagResolutionNote   String?  @db.Text

  // Review workflow fields (separate from flagging)
  reviewStatus         RowReviewStatus @default(NONE)
  reviewRequestedAt    DateTime?
  reviewRequestedBy    String?
  reviewNote           String?  @db.Text  // Note from requester to reviewer
  assignedReviewerId   String?  // User ID of assigned reviewer (null = anyone can review)
  assignedReviewerName String?  // Cached name for display
  reviewedAt           DateTime?
  reviewedBy           String?
  userEditedAnswer     String? @db.Text  // If user/reviewer corrected the answer

  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([flaggedForReview])
  // Composite indexes for question log queries
  @@index([reviewStatus, createdAt])
  @@index([flagResolved, flaggedForReview])
}

// Chat Session - tracks full chat conversations in The Oracle
model ChatSession {
  id              String   @id @default(uuid())
  userId          String?  // Optional - null for anonymous users
  userEmail       String?  // For display purposes
  title           String?  // Auto-generated or user-editable title
  messages        Json     // Array of {id, role, content, timestamp, skillsUsed?, documentsUsed?, urlsUsed?, customersUsed?}
  skillsUsed      Json?    // Skills selected for this session
  documentsUsed   Json?    // Documents selected
  customersUsed   Json?    // Customer profiles selected
  urlsUsed        Json?    // Reference URLs selected
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, updatedAt])
  @@index([createdAt])
}

// API Usage Tracking - logs token usage and costs per API call
model ApiUsage {
  id              String   @id @default(uuid())
  userId          String?  // Optional - null for anonymous users
  userEmail       String?  // For display purposes
  feature         String   // e.g., "questions", "chat", "skills-suggest", "projects"
  model           String   // e.g., "claude-sonnet-4-20250514"
  inputTokens     Int
  outputTokens    Int
  totalTokens     Int
  estimatedCost   Float    // Calculated cost in USD
  metadata        Json?    // Additional context (e.g., skill count, question length)
  createdAt       DateTime @default(now())

  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([feature, createdAt])
  @@index([createdAt])
}

// App Settings - key-value store for admin-configurable settings
// NOTE: Security engineer should implement encryption for sensitive values
model AppSetting {
  key         String   @id // e.g., "SALESFORCE_CLIENT_ID"
  value       String   @db.Text // The setting value (TODO: encrypt sensitive values)
  description String?  // Human-readable description
  isSecret    Boolean  @default(false) // Whether this is a sensitive value
  updatedAt   DateTime @updatedAt
  updatedBy   String?  // Email of user who last updated
}

// Audit Log - tracks all changes across entities
model AuditLog {
  id            String         @id @default(uuid())
  entityType    AuditEntityType // skill, customer, project, document, etc.
  entityId      String         // ID of the affected entity
  entityTitle   String?        // Human-readable title/name of the entity
  action        AuditAction    // created, updated, deleted, etc.
  userId        String?        // User who performed the action
  userEmail     String?        // For display purposes
  userName      String?        // For display purposes
  changes       Json?          // Detailed changes: {field: {from, to}}
  metadata      Json?          // Additional context
  ipAddress     String?        // IP address if available
  userAgent     String?        // Browser/client info
  createdAt     DateTime       @default(now())

  @@index([entityType, entityId])
  @@index([userId, createdAt])
  @@index([entityType, createdAt])
  @@index([createdAt])
}

enum AuditEntityType {
  SKILL
  CUSTOMER
  PROJECT
  DOCUMENT
  REFERENCE_URL
  CONTRACT
  USER
  SETTING
  PROMPT
  CONTEXT_SNIPPET
  ANSWER
}

enum AuditAction {
  CREATED
  UPDATED
  DELETED
  VIEWED
  EXPORTED
  OWNER_ADDED
  OWNER_REMOVED
  STATUS_CHANGED
  REFRESHED
  MERGED
  CORRECTED
  APPROVED
  REVIEW_REQUESTED
  FLAG_RESOLVED
  CLARIFY_USED
}

// Answer Feedback - tracks user ratings on AI-generated responses
model AnswerFeedback {
  id              String          @id @default(uuid())
  userId          String?         // User who gave feedback
  userEmail       String?         // For display purposes
  feature         String          // "questions", "chat", "projects" - which feature generated this
  rating          FeedbackRating  // thumbs_up, thumbs_down
  comment         String?         @db.Text // Optional user comment

  // Context about the answer
  question        String          @db.Text // The question asked
  answer          String          @db.Text // The AI's response
  confidence      String?         // The confidence level if applicable
  skillsUsed      Json?           // Skills that were used

  // Optional references to source entities
  questionHistoryId String?       // If from quick questions
  bulkRowId         String?       // If from a project row
  chatSessionId     String?       // If from chat

  // Metadata
  model           String?         // Which AI model was used
  usedFallback    Boolean         @default(false) // Whether fallback was used
  metadata        Json?           // Additional context

  createdAt       DateTime        @default(now())

  user            User?           @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([feature, createdAt])
  @@index([rating, createdAt])
  @@index([userId, createdAt])
  @@index([createdAt])
}

enum FeedbackRating {
  THUMBS_UP
  THUMBS_DOWN
}

// Document Templates - reusable templates for deliverables
// Used by Chat V2 to generate filled documents (battlecards, proposals, etc.)
model Template {
  id                  String         @id @default(uuid())
  name                String         // Human-readable name, e.g., "Sales Battlecard"
  description         String?        // Brief description of what this template is for
  content             String         @db.Text // Markdown template with placeholders
  category            String?        // Grouping: "Sales", "Marketing", "Technical"
  outputFormat        String         @default("markdown") // markdown, docx (for future export)
  placeholderHint     String?        @db.Text // Guidance on available placeholders (deprecated - use placeholderMappings)
  // Placeholder mappings - defines how each {{placeholder}} maps to data sources
  // JSON array of { placeholder: string, source: PlaceholderSource, field?: string, fallback?: string, llmInstruction?: string }
  placeholderMappings Json?
  // Link to instruction preset - auto-selects this persona when template is chosen
  instructionPresetId String?
  isActive            Boolean        @default(true)
  sortOrder           Int            @default(0)
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  createdBy           String?        // User email who created it
  updatedBy           String?        // User email who last updated

  @@index([category])
  @@index([isActive])
  @@index([sortOrder])
  @@index([instructionPresetId])
}

// Collateral Output - tracks generated collateral from templates
// Used by Collateral Builder to store filled templates and track review status
model CollateralOutput {
  id                  String               @id @default(uuid())
  name                String               // User-given or auto-generated name

  // Source references
  templateId          String?              // Template used (if any)
  templateName        String?              // Snapshot of template name at creation
  customerId          String?              // Customer context used
  customerName        String?              // Snapshot of customer name

  // Generated content
  filledContent       Json?                // Key-value pairs of placeholder -> value
  generatedMarkdown   String?              @db.Text // Final markdown output
  googleSlidesId      String?              // If exported to Google Slides
  googleSlidesUrl     String?              // URL to the filled presentation

  // Status and workflow
  status              CollateralStatus     @default(DRAFT)

  // Flagging (same pattern as BulkRow)
  flaggedForReview    Boolean              @default(false)
  flaggedAt           DateTime?
  flaggedBy           String?
  flagNote            String?              @db.Text
  flagResolved        Boolean              @default(false)
  flagResolvedAt      DateTime?
  flagResolvedBy      String?
  flagResolutionNote  String?              @db.Text

  // Review workflow (same pattern as BulkRow)
  reviewStatus        RowReviewStatus      @default(NONE)
  reviewRequestedAt   DateTime?
  reviewRequestedBy   String?
  reviewNote          String?              @db.Text
  assignedReviewerId  String?
  assignedReviewerName String?
  reviewedAt          DateTime?
  reviewedBy          String?

  // Queue for batch review
  queuedForReview     Boolean              @default(false)
  queuedAt            DateTime?
  queuedBy            String?
  queuedNote          String?              @db.Text
  queuedReviewerId    String?
  queuedReviewerName  String?

  // Feedback
  rating              FeedbackRating?
  feedbackComment     String?              @db.Text

  // Metadata
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  createdBy           String?
  ownerId             String?

  owner               User?                @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  customer            CustomerProfile?     @relation(fields: [customerId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([customerId])
  @@index([templateId])
  @@index([ownerId])
  @@index([flaggedForReview])
  @@index([reviewStatus])
  @@index([queuedForReview])
  @@index([createdAt])
  // Composite indexes for common queries
  @@index([ownerId, status])
  @@index([ownerId, createdAt])
}

enum CollateralStatus {
  DRAFT           // In progress, not finished
  GENERATED       // AI generated content
  EXPORTED        // Exported to Google Slides
  NEEDS_REVIEW    // Sent for review
  APPROVED        // Reviewed and approved
  FINALIZED       // Final version, locked
}

// Chat message feedback - tracks user ratings and flags for chat responses
model ChatFeedback {
  id              String    @id @default(cuid())
  messageId       String    // Client-side message ID
  sessionId       String    // Chat session ID (or "no-session")
  userId          String    // User who gave feedback
  orgId           String?   // User's organization

  // Rating
  rating          String?   // "THUMBS_UP" | "THUMBS_DOWN"
  comment         String?   @db.Text

  // Flagging
  flaggedForReview Boolean  @default(false)
  flagNote         String?  @db.Text

  // Review request
  reviewRequested  Boolean  @default(false)
  reviewerId       String?  // User ID of requested reviewer
  reviewerName     String?  // Display name of reviewer
  reviewNote       String?  @db.Text
  sendNow          Boolean  @default(false) // Send notification immediately vs queue

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@unique([messageId, sessionId])
  @@index([userId])
  @@index([orgId])
  @@index([sessionId])
  @@index([flaggedForReview])
  @@index([reviewRequested])
  @@index([createdAt])
}

